expData <- data.frame(
Sample = samples,
cols = as.hexcol(sample.cols),
Group = groups,
counts)
expData
}
testing(fit, counts=vm)
return(counts)
testing <- function(fit, counts, groups=1:ncol(counts), logTransform=FALSE)
{
if (is.null(colnames(counts)))
{
samples <- seq_len(ncol(counts))
}
else
{
samples <- colnames(counts)
}
# process counts
cols <- colnames(counts)
return(counts)
rownames(counts) <- make.names(cols)
if (logTransform)
{
counts <- as.matrix(edgeR::cpm(counts, log=TRUE))
}
else
{
counts <- as.matrix(counts)
}
counts <- t(counts)
return(counts)
if (!is.numeric(groups))
{
# reorder samples to group levels
groups <- factor(groups)
counts <- counts[order(groups), ]
sample.cols <- sample.cols[order(groups)]
samples <- samples[order(groups)]
groups <- sort(groups)
}
expData <- data.frame(
Sample = samples,
cols = as.hexcol(sample.cols),
Group = groups,
counts)
expData
}
testing(fit, counts=vm)
rownames(counts)
rownames(vm)
colnames(vm)
make.names(colnames(vm))
library(Glimma)
library(limma)
library(GlimmaV2)
data(lymphomaRNAseq)
rnaseq <- lymphomaRNAseq
# add lane
groups <- data.frame(genotype=rnaseq$samples$group,
lane= as.character(c(rep(4,5),3,3)),
miscCont=c(rep(4000,5),300,250),
miscDisc=c("blue","red",rep("green",5)))
# add libsize
groups <- rnaseq$samples$group
# fit
design <- model.matrix(~0+groups)
contrasts <- cbind(Smchd1null.vs.WT=c(-1,1))
vm <- voomWithQualityWeights(rnaseq, design=design)
fit <- lmFit(vm, design=design)
fit <- contrasts.fit(fit, contrasts)
fit <- eBayes(fit)
dt <- decideTests(fit)
summary(dt)
fit
fit$genes
# object has a bunch of genes
nrow(fit$genes)
fit$coefficients
fit$Amean
data.frame(fit$Amean)
# object has a bunch of genes
nrow(fit$genes)
# fold change is the column here
# each instance is a gene;
# the
fit$coefficients
ncol(fit$coefficients)
names(fit$coefficients)
names(fit$coefficients[,1])
fit$coefficients
# object has a bunch of genes
nrow(fit$genes)
# fold change is the column here
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is fold change (Smchd1null vs WT)
fit$coefficients
fit$Amean
data.frame(fit$Amean)
# fold change is the column here
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is fold change (Smchd1null vs WT)
data.frame(fit$coefficients)
rnaseq$counts
data.frame(rnaseq$counts)
model.matrix(~0+groups)
glMDPlot(fit, status=dt, counts=vm, groups=groups, side.main="Symbols")
vm
vm$E
data.frame(vm$E)
library(scRNAseq)
install.packages("scRNAseq")
install.packages("SingleCellExperiment")
fit$design
groups
# this is where info for the MD scatter plot comes from!
data.frame(vm$E)
fit$design
library(Glimma)
library(limma)
library(GlimmaV2)
data(lymphomaRNAseq)
rnaseq <- lymphomaRNAseq
# 7 samples
# each instance is a gene
# attribute is number of counts per sample
data.frame(rnaseq$counts)
# add lane
groups <- data.frame(genotype=rnaseq$samples$group,
lane= as.character(c(rep(4,5),3,3)),
miscCont=c(rep(4000,5),300,250),
miscDisc=c("blue","red",rep("green",5)))
# add libsize
groups <- rnaseq$samples$group
# fit
design <- model.matrix(~0+groups)
contrasts <- cbind(Smchd1null.vs.WT=c(-1,1))
# convert raw counts to logCPM values by automatically extracting libsizes and normalisation factors from x
vm <- voomWithQualityWeights(rnaseq, design=design)
fit <- lmFit(vm, design=design)
fit <- contrasts.fit(fit, contrasts)
fit <- eBayes(fit)
dt <- decideTests(fit)
summary(dt)
testing <- function(fit, counts, groups=1:ncol(counts), logTransform=FALSE)
{
if (is.null(colnames(counts)))
{
samples <- seq_len(ncol(counts))
}
else
{
samples <- colnames(counts)
}
# process counts
cols <- colnames(counts)
rownames(counts) <- make.names(cols)
if (logTransform)
{
counts <- as.matrix(edgeR::cpm(counts, log=TRUE))
}
else
{
counts <- as.matrix(counts)
}
counts <- t(counts)
return(counts)
if (!is.numeric(groups))
{
# reorder samples to group levels
groups <- factor(groups)
counts <- counts[order(groups), ]
sample.cols <- sample.cols[order(groups)]
samples <- samples[order(groups)]
groups <- sort(groups)
}
expData <- data.frame(
Sample = samples,
cols = as.hexcol(sample.cols),
Group = groups,
counts)
expData
}
# object has a bunch of genes
nrow(fit$genes)
# fold change is the attribute here
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is fold change (Smchd1null vs WT)
data.frame(fit$coefficients)
# log cpm is the attribute here
# averaged across all arrays in the original linear model fit
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is mean expression
data.frame(fit$Amean)
# this is where info for the MD scatter plot comes from!
data.frame(vm$E)
fit$design
GlimmaV2("MDS", fit)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(Glimma)
library(limma)
library(GlimmaV2)
data(lymphomaRNAseq)
rnaseq <- lymphomaRNAseq
# 7 samples
# each instance is a gene
# attribute is number of counts per sample
# data.frame(rnaseq$counts)
# add lane
groups <- data.frame(genotype=rnaseq$samples$group,
lane= as.character(c(rep(4,5),3,3)),
miscCont=c(rep(4000,5),300,250),
miscDisc=c("blue","red",rep("green",5)))
# add libsize
groups <- rnaseq$samples$group
# fit
design <- model.matrix(~0+groups)
contrasts <- cbind(Smchd1null.vs.WT=c(-1,1))
# convert raw counts to logCPM values by automatically extracting libsizes and normalisation factors from x
vm <- voomWithQualityWeights(rnaseq, design=design)
fit <- lmFit(vm, design=design)
fit <- contrasts.fit(fit, contrasts)
fit <- eBayes(fit)
dt <- decideTests(fit)
summary(dt)
testing <- function(fit, counts, groups=1:ncol(counts), logTransform=FALSE)
{
if (is.null(colnames(counts)))
{
samples <- seq_len(ncol(counts))
}
else
{
samples <- colnames(counts)
}
# process counts
cols <- colnames(counts)
rownames(counts) <- make.names(cols)
if (logTransform)
{
counts <- as.matrix(edgeR::cpm(counts, log=TRUE))
}
else
{
counts <- as.matrix(counts)
}
counts <- t(counts)
return(counts)
if (!is.numeric(groups))
{
# reorder samples to group levels
groups <- factor(groups)
counts <- counts[order(groups), ]
sample.cols <- sample.cols[order(groups)]
samples <- samples[order(groups)]
groups <- sort(groups)
}
expData <- data.frame(
Sample = samples,
cols = as.hexcol(sample.cols),
Group = groups,
counts)
expData
}
# object has a bunch of genes
nrow(fit$genes)
# fold change is the attribute here
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is fold change (Smchd1null vs WT)
# data.frame(fit$coefficients)
# log cpm is the attribute here
# averaged across all arrays in the original linear model fit
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is mean expression
# data.frame(fit$Amean)
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
fit$genes
names(fit$genes)
rownames(fit$genes)
rownames(fit$genes) == rownames(fit$Amean)
rownames(fit$Amean)
fit$Amean
fit$Amean[,1]
ndim(fit$Amean)
dim(fit$Amean)
fit$Amean
colnames(fit$Amean)
rownames(fit$Amean)
names(fit$Amean)
rownames(fit$genes) == names(fit$Amean)
all(rownames(fit$genes) == names(fit$Amean))
cbind(fit$genes,logcpm=logcpm, logfc=logfc)
# log cpm is the attribute here
# averaged across all arrays in the original linear model fit
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is mean expression
# data.frame(fit$Amean)
# for now assume fit object
logcpm <- unname(fit$Amean)
logfc <- unname(fit$coefficients[,1])
names <- names(fit$Amean)
cbind(fit$genes,logcpm=logcpm, logfc=logfc)
table <-cbind(fit$genes,logcpm=logcpm, logfc=logfc)
colnames(table)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
rmarkdown::pandoc_version()
install.packages("pandoc")
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(Glimma)
library(limma)
library(GlimmaV2)
data(lymphomaRNAseq)
rnaseq <- lymphomaRNAseq
# 7 samples
# each instance is a gene
# attribute is number of counts per sample
# data.frame(rnaseq$counts)
# add lane
groups <- data.frame(genotype=rnaseq$samples$group,
lane= as.character(c(rep(4,5),3,3)),
miscCont=c(rep(4000,5),300,250),
miscDisc=c("blue","red",rep("green",5)))
# add libsize
groups <- rnaseq$samples$group
# fit
design <- model.matrix(~0+groups)
contrasts <- cbind(Smchd1null.vs.WT=c(-1,1))
# convert raw counts to logCPM values by automatically extracting libsizes and normalisation factors from x
vm <- voomWithQualityWeights(rnaseq, design=design)
fit <- lmFit(vm, design=design)
fit <- contrasts.fit(fit, contrasts)
fit <- eBayes(fit)
dt <- decideTests(fit)
summary(dt)
testing <- function(fit, counts, groups=1:ncol(counts), logTransform=FALSE)
{
if (is.null(colnames(counts)))
{
samples <- seq_len(ncol(counts))
}
else
{
samples <- colnames(counts)
}
# process counts
cols <- colnames(counts)
rownames(counts) <- make.names(cols)
if (logTransform)
{
counts <- as.matrix(edgeR::cpm(counts, log=TRUE))
}
else
{
counts <- as.matrix(counts)
}
counts <- t(counts)
return(counts)
if (!is.numeric(groups))
{
# reorder samples to group levels
groups <- factor(groups)
counts <- counts[order(groups), ]
sample.cols <- sample.cols[order(groups)]
samples <- samples[order(groups)]
groups <- sort(groups)
}
expData <- data.frame(
Sample = samples,
cols = as.hexcol(sample.cols),
Group = groups,
counts)
expData
}
# object has a bunch of genes
nrow(fit$genes)
# fold change is the attribute here
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is fold change (Smchd1null vs WT)
# data.frame(fit$coefficients)
# log cpm is the attribute here
# averaged across all arrays in the original linear model fit
# each instance is a gene;
# the col vector names are the geneIDs
# the col vector attribute is mean expression
# data.frame(fit$Amean)
# for now assume fit object
# this is where info for the MD scatter plot comes from!
# data.frame(vm$E)
# fit$design
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
GlimmaV2("Ma", fit)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
# for now assume fit object
fit$rank
# for now assume fit object
fit$contrasts
# for now assume fit object
fit$rank
# for now assume fit object
fit$s2.post
# for now assume fit object
fit$p.value
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
library(GlimmaV2)
library(GlimmaV2)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
library(GlimmaV2)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
GlimmaV2("MA", fit)
